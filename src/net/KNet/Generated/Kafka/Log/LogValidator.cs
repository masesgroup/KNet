/*
*  Copyright 2023 MASES s.r.l.
*
*  Licensed under the Apache License, Version 2.0 (the "License");
*  you may not use this file except in compliance with the License.
*  You may obtain a copy of the License at
*
*  http://www.apache.org/licenses/LICENSE-2.0
*
*  Unless required by applicable law or agreed to in writing, software
*  distributed under the License is distributed on an "AS IS" BASIS,
*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*  See the License for the specific language governing permissions and
*  limitations under the License.
*
*  Refer to LICENSE for more information.
*/

/*
*  This file is generated by MASES.JNetReflector (ver. 1.5.5.0)
*  using kafka_2.13-3.4.0.jar as reference
*/

using MASES.JCOBridge.C2JBridge;

namespace Kafka.Log
{
    #region LogValidator
    public partial class LogValidator
    {
        #region Constructors

        #endregion

        #region Class/Interface conversion operators

        #endregion

        #region Fields

        #endregion

        #region Static methods
        /// <summary>
        /// <see href="https://www.javadoc.io/static/org.apache.kafka/kafka_2.13/3.4.0/kafka/log/LogValidator.html#isDebugEnabled()"/> 
        /// </summary>
        public static bool IsDebugEnabled
        {
            get { return SExecute<bool>(LocalBridgeClazz, "isDebugEnabled"); }
        }
        /// <summary>
        /// <see href="https://www.javadoc.io/static/org.apache.kafka/kafka_2.13/3.4.0/kafka/log/LogValidator.html#isTraceEnabled()"/> 
        /// </summary>
        public static bool IsTraceEnabled
        {
            get { return SExecute<bool>(LocalBridgeClazz, "isTraceEnabled"); }
        }
        /// <summary>
        /// <see href="https://www.javadoc.io/static/org.apache.kafka/kafka_2.13/3.4.0/kafka/log/LogValidator.html#assignOffsetsNonCompressed(org.apache.kafka.common.record.MemoryRecords,org.apache.kafka.common.TopicPartition,kafka.common.LongRef,long,boolean,org.apache.kafka.common.record.TimestampType,long,int,kafka.log.AppendOrigin,byte,kafka.server.BrokerTopicStats)"/>
        /// </summary>
        /// <param name="records"><see cref="Org.Apache.Kafka.Common.Record.MemoryRecords"/></param>
        /// <param name="topicPartition"><see cref="Org.Apache.Kafka.Common.TopicPartition"/></param>
        /// <param name="offsetCounter"><see cref="Kafka.Common.LongRef"/></param>
        /// <param name="now"><see cref="long"/></param>
        /// <param name="compactedTopic"><see cref="bool"/></param>
        /// <param name="timestampType"><see cref="Org.Apache.Kafka.Common.Record.TimestampType"/></param>
        /// <param name="timestampDiffMaxMs"><see cref="long"/></param>
        /// <param name="partitionLeaderEpoch"><see cref="int"/></param>
        /// <param name="origin"><see cref="Kafka.Log.AppendOrigin"/></param>
        /// <param name="magic"><see cref="byte"/></param>
        /// <param name="brokerTopicStats"><see cref="Kafka.Server.BrokerTopicStats"/></param>
        /// <returns><see cref="Kafka.Log.LogValidator.ValidationAndOffsetAssignResult"/></returns>
        public static Kafka.Log.LogValidator.ValidationAndOffsetAssignResult AssignOffsetsNonCompressed(Org.Apache.Kafka.Common.Record.MemoryRecords records, Org.Apache.Kafka.Common.TopicPartition topicPartition, Kafka.Common.LongRef offsetCounter, long now, bool compactedTopic, Org.Apache.Kafka.Common.Record.TimestampType timestampType, long timestampDiffMaxMs, int partitionLeaderEpoch, Kafka.Log.AppendOrigin origin, byte magic, Kafka.Server.BrokerTopicStats brokerTopicStats)
        {
            return SExecute<Kafka.Log.LogValidator.ValidationAndOffsetAssignResult>(LocalBridgeClazz, "assignOffsetsNonCompressed", records, topicPartition, offsetCounter, now, compactedTopic, timestampType, timestampDiffMaxMs, partitionLeaderEpoch, origin, magic, brokerTopicStats);
        }
        /// <summary>
        /// <see href="https://www.javadoc.io/static/org.apache.kafka/kafka_2.13/3.4.0/kafka/log/LogValidator.html#validateMessagesAndAssignOffsetsCompressed(org.apache.kafka.common.record.MemoryRecords,org.apache.kafka.common.TopicPartition,kafka.common.LongRef,org.apache.kafka.common.utils.Time,long,kafka.message.CompressionCodec,kafka.message.CompressionCodec,boolean,byte,org.apache.kafka.common.record.TimestampType,long,int,kafka.log.AppendOrigin,org.apache.kafka.server.common.MetadataVersion,kafka.server.BrokerTopicStats,kafka.server.RequestLocal)"/>
        /// </summary>
        /// <param name="records"><see cref="Org.Apache.Kafka.Common.Record.MemoryRecords"/></param>
        /// <param name="topicPartition"><see cref="Org.Apache.Kafka.Common.TopicPartition"/></param>
        /// <param name="offsetCounter"><see cref="Kafka.Common.LongRef"/></param>
        /// <param name="time"><see cref="Org.Apache.Kafka.Common.Utils.Time"/></param>
        /// <param name="now"><see cref="long"/></param>
        /// <param name="sourceCodec"><see cref="Kafka.Message.CompressionCodec"/></param>
        /// <param name="targetCodec"><see cref="Kafka.Message.CompressionCodec"/></param>
        /// <param name="compactedTopic"><see cref="bool"/></param>
        /// <param name="toMagic"><see cref="byte"/></param>
        /// <param name="timestampType"><see cref="Org.Apache.Kafka.Common.Record.TimestampType"/></param>
        /// <param name="timestampDiffMaxMs"><see cref="long"/></param>
        /// <param name="partitionLeaderEpoch"><see cref="int"/></param>
        /// <param name="origin"><see cref="Kafka.Log.AppendOrigin"/></param>
        /// <param name="interBrokerProtocolVersion"><see cref="Org.Apache.Kafka.Server.Common.MetadataVersion"/></param>
        /// <param name="brokerTopicStats"><see cref="Kafka.Server.BrokerTopicStats"/></param>
        /// <param name="requestLocal"><see cref="Kafka.Server.RequestLocal"/></param>
        /// <returns><see cref="Kafka.Log.LogValidator.ValidationAndOffsetAssignResult"/></returns>
        public static Kafka.Log.LogValidator.ValidationAndOffsetAssignResult ValidateMessagesAndAssignOffsetsCompressed(Org.Apache.Kafka.Common.Record.MemoryRecords records, Org.Apache.Kafka.Common.TopicPartition topicPartition, Kafka.Common.LongRef offsetCounter, Org.Apache.Kafka.Common.Utils.Time time, long now, Kafka.Message.CompressionCodec sourceCodec, Kafka.Message.CompressionCodec targetCodec, bool compactedTopic, byte toMagic, Org.Apache.Kafka.Common.Record.TimestampType timestampType, long timestampDiffMaxMs, int partitionLeaderEpoch, Kafka.Log.AppendOrigin origin, Org.Apache.Kafka.Server.Common.MetadataVersion interBrokerProtocolVersion, Kafka.Server.BrokerTopicStats brokerTopicStats, Kafka.Server.RequestLocal requestLocal)
        {
            return SExecute<Kafka.Log.LogValidator.ValidationAndOffsetAssignResult>(LocalBridgeClazz, "validateMessagesAndAssignOffsetsCompressed", records, topicPartition, offsetCounter, time, now, sourceCodec, targetCodec, compactedTopic, toMagic, timestampType, timestampDiffMaxMs, partitionLeaderEpoch, origin, interBrokerProtocolVersion, brokerTopicStats, requestLocal);
        }

        #endregion

        #region Instance methods

        #endregion

        #region Nested classes
        #region ValidationAndOffsetAssignResult
        public partial class ValidationAndOffsetAssignResult
        {
            #region Constructors
            /// <summary>
            /// <see href="https://www.javadoc.io/static/org.apache.kafka/kafka_2.13/3.4.0/kafka/log/LogValidator.ValidationAndOffsetAssignResult.html#%3Cinit%3E(org.apache.kafka.common.record.MemoryRecords,long,long,boolean,org.apache.kafka.common.record.RecordConversionStats)"/>
            /// </summary>
            /// <param name="validatedRecords"><see cref="Org.Apache.Kafka.Common.Record.MemoryRecords"/></param>
            /// <param name="maxTimestamp"><see cref="long"/></param>
            /// <param name="shallowOffsetOfMaxTimestamp"><see cref="long"/></param>
            /// <param name="messageSizeMaybeChanged"><see cref="bool"/></param>
            /// <param name="recordConversionStats"><see cref="Org.Apache.Kafka.Common.Record.RecordConversionStats"/></param>
            public ValidationAndOffsetAssignResult(Org.Apache.Kafka.Common.Record.MemoryRecords validatedRecords, long maxTimestamp, long shallowOffsetOfMaxTimestamp, bool messageSizeMaybeChanged, Org.Apache.Kafka.Common.Record.RecordConversionStats recordConversionStats)
                : base(validatedRecords, maxTimestamp, shallowOffsetOfMaxTimestamp, messageSizeMaybeChanged, recordConversionStats)
            {
            }

            #endregion

            #region Class/Interface conversion operators
            /// <summary>
            /// Converter from <see cref="Kafka.Log.LogValidator.ValidationAndOffsetAssignResult"/> to <see cref="Java.Io.Serializable"/>
            /// </summary>
            public static implicit operator Java.Io.Serializable(Kafka.Log.LogValidator.ValidationAndOffsetAssignResult t) => t.Cast<Java.Io.Serializable>();

            #endregion

            #region Fields

            #endregion

            #region Static methods

            #endregion

            #region Instance methods
            /// <summary>
            /// <see href="https://www.javadoc.io/static/org.apache.kafka/kafka_2.13/3.4.0/kafka/log/LogValidator.ValidationAndOffsetAssignResult.html#maxTimestamp()"/> 
            /// </summary>
            public long MaxTimestamp
            {
                get { return IExecute<long>("maxTimestamp"); }
            }
            /// <summary>
            /// <see href="https://www.javadoc.io/static/org.apache.kafka/kafka_2.13/3.4.0/kafka/log/LogValidator.ValidationAndOffsetAssignResult.html#messageSizeMaybeChanged()"/> 
            /// </summary>
            public bool MessageSizeMaybeChanged
            {
                get { return IExecute<bool>("messageSizeMaybeChanged"); }
            }
            /// <summary>
            /// <see href="https://www.javadoc.io/static/org.apache.kafka/kafka_2.13/3.4.0/kafka/log/LogValidator.ValidationAndOffsetAssignResult.html#productArity()"/> 
            /// </summary>
            public int ProductArity
            {
                get { return IExecute<int>("productArity"); }
            }
            /// <summary>
            /// <see href="https://www.javadoc.io/static/org.apache.kafka/kafka_2.13/3.4.0/kafka/log/LogValidator.ValidationAndOffsetAssignResult.html#productPrefix()"/> 
            /// </summary>
            public string ProductPrefix
            {
                get { return IExecute<string>("productPrefix"); }
            }
            /// <summary>
            /// <see href="https://www.javadoc.io/static/org.apache.kafka/kafka_2.13/3.4.0/kafka/log/LogValidator.ValidationAndOffsetAssignResult.html#recordConversionStats()"/> 
            /// </summary>
            public Org.Apache.Kafka.Common.Record.RecordConversionStats RecordConversionStats
            {
                get { return IExecute<Org.Apache.Kafka.Common.Record.RecordConversionStats>("recordConversionStats"); }
            }
            /// <summary>
            /// <see href="https://www.javadoc.io/static/org.apache.kafka/kafka_2.13/3.4.0/kafka/log/LogValidator.ValidationAndOffsetAssignResult.html#shallowOffsetOfMaxTimestamp()"/> 
            /// </summary>
            public long ShallowOffsetOfMaxTimestamp
            {
                get { return IExecute<long>("shallowOffsetOfMaxTimestamp"); }
            }
            /// <summary>
            /// <see href="https://www.javadoc.io/static/org.apache.kafka/kafka_2.13/3.4.0/kafka/log/LogValidator.ValidationAndOffsetAssignResult.html#validatedRecords()"/> 
            /// </summary>
            public Org.Apache.Kafka.Common.Record.MemoryRecords ValidatedRecords
            {
                get { return IExecute<Org.Apache.Kafka.Common.Record.MemoryRecords>("validatedRecords"); }
            }
            /// <summary>
            /// <see href="https://www.javadoc.io/static/org.apache.kafka/kafka_2.13/3.4.0/kafka/log/LogValidator.ValidationAndOffsetAssignResult.html#canEqual(java.lang.Object)"/>
            /// </summary>
            /// <param name="x$1"><see cref="object"/></param>
            /// <returns><see cref="bool"/></returns>
            public bool CanEqual(object x_1)
            {
                return IExecute<bool>("canEqual", x_1);
            }
            /// <summary>
            /// <see href="https://www.javadoc.io/static/org.apache.kafka/kafka_2.13/3.4.0/kafka/log/LogValidator.ValidationAndOffsetAssignResult.html#productElement(int)"/>
            /// </summary>
            /// <param name="x$1"><see cref="int"/></param>
            /// <returns><see cref="object"/></returns>
            public object ProductElement(int x_1)
            {
                return IExecute("productElement", x_1);
            }
            /// <summary>
            /// <see href="https://www.javadoc.io/static/org.apache.kafka/kafka_2.13/3.4.0/kafka/log/LogValidator.ValidationAndOffsetAssignResult.html#productElementName(int)"/>
            /// </summary>
            /// <param name="x$1"><see cref="int"/></param>
            /// <returns><see cref="string"/></returns>
            public string ProductElementName(int x_1)
            {
                return IExecute<string>("productElementName", x_1);
            }
            /// <summary>
            /// <see href="https://www.javadoc.io/static/org.apache.kafka/kafka_2.13/3.4.0/kafka/log/LogValidator.ValidationAndOffsetAssignResult.html#copy(org.apache.kafka.common.record.MemoryRecords,long,long,boolean,org.apache.kafka.common.record.RecordConversionStats)"/>
            /// </summary>
            /// <param name="validatedRecords"><see cref="Org.Apache.Kafka.Common.Record.MemoryRecords"/></param>
            /// <param name="maxTimestamp"><see cref="long"/></param>
            /// <param name="shallowOffsetOfMaxTimestamp"><see cref="long"/></param>
            /// <param name="messageSizeMaybeChanged"><see cref="bool"/></param>
            /// <param name="recordConversionStats"><see cref="Org.Apache.Kafka.Common.Record.RecordConversionStats"/></param>
            /// <returns><see cref="Kafka.Log.LogValidator.ValidationAndOffsetAssignResult"/></returns>
            public Kafka.Log.LogValidator.ValidationAndOffsetAssignResult Copy(Org.Apache.Kafka.Common.Record.MemoryRecords validatedRecords, long maxTimestamp, long shallowOffsetOfMaxTimestamp, bool messageSizeMaybeChanged, Org.Apache.Kafka.Common.Record.RecordConversionStats recordConversionStats)
            {
                return IExecute<Kafka.Log.LogValidator.ValidationAndOffsetAssignResult>("copy", validatedRecords, maxTimestamp, shallowOffsetOfMaxTimestamp, messageSizeMaybeChanged, recordConversionStats);
            }

            #endregion

            #region Nested classes

            #endregion

            // TODO: complete the class
        }
        #endregion

    
        #endregion

        // TODO: complete the class
    }
    #endregion
}